
.. _program_listing_file__home_runner_work_Args-Engine_Args-Engine_args_core_filesystem_resource.hpp:

Program Listing for File resource.hpp
=====================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Args-Engine_Args-Engine_args_core_filesystem_resource.hpp>` (``/home/runner/work/Args-Engine/Args-Engine/args/core/filesystem/resource.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <core/types/types.hpp>       // byte_vec
   #include <core/platform/platform.hpp> // A_NODISCARD
   
   #include <string_view>                // std::string_view
   
   #include "detail/resource_meta.hpp"   //has_to_resource<T,Sig>, has_from_resource<T,Sig>
   
   
   namespace args::core::filesystem
   {
   
   class Test {
   
   };
   
   
       class basic_resource
       {
       public:
   
           explicit basic_resource(nullptr_t) : m_container{}{}
   
           explicit basic_resource(byte_vec v) : m_container(std::move(v)) {}
   
           explicit basic_resource(const std::string_view& v) : basic_resource(nullptr)
           {
               m_container.assign(v.begin(), v.end());
           }
   
           //copy & move operations
           basic_resource(const basic_resource& other) = default;
           basic_resource(basic_resource&& other) noexcept = default;
           basic_resource& operator=(const basic_resource& other) = default;
           basic_resource& operator=(basic_resource&& other) noexcept = default;
   
           //stl operators
   
           A_NODISCARD auto begin() noexcept
           {
               return m_container.begin();
           }
           
           A_NODISCARD auto begin() const noexcept
           {
               return m_container.begin();
           }
   
           A_NODISCARD auto end() noexcept
           {
               return m_container.end();
           }
   
           A_NODISCARD auto end() const noexcept
           {
               return m_container.end();
           }
   
           A_NODISCARD auto data() noexcept
           {
               return m_container.data();
           }
   
           A_NODISCARD auto data() const noexcept
           {
               return m_container.data();
           }
   
           A_NODISCARD auto size() const noexcept
           {
               return m_container.size();
           }
   
           A_NODISCARD auto empty() const noexcept
           {
               return m_container.empty();
           }
   
           A_NODISCARD byte_vec& get() noexcept
           {
               return m_container;
           }
           
           A_NODISCARD const byte_vec& get() const noexcept
           {
               return m_container;
           }
   
           basic_resource& operator=(const std::string_view& value)
           {
               m_container.assign(value.begin(),value.end());
               return *this;
           }
           
           A_NODISCARD std::string to_string() const
           {
               const char* const cstr = reinterpret_cast<const char*>(data());
               return std::string(cstr,size());
           }
   
   
           template <class T,class... Args>
           A_NODISCARD T to(Args&&...args);
   
           template <class T>
           void from(const T& v);
           
       private:
           byte_vec m_container;
       };
   
       #ifndef DOXY_EXCLUDE
   
       template <  typename T,
                   typename C1 = std::enable_if<detail::has_to_resource<T,void(basic_resource*,const T&)>::value>>
       void to_resource(basic_resource* resource,const T& value)
       {
           T::to_resource(resource,value);
       }
   
       template <  typename T,
                   typename C1 = std::enable_if<detail::has_to_resource<T,void(basic_resource*,const T&)>::value>>
       basic_resource to_resource(const T& value)
       {
           basic_resource res(nullptr);
           T::to_resource(&res,value);
           return res;
       }
       
   
       template <  typename T,
                   typename C1 = std::enable_if<detail::has_from_resource<T,void(T*,const basic_resource&)>::value>>
       void from_resource(T* value, const basic_resource& resource)
       {
           T::from_resource(value,resource);
       }
       template <  typename T,
                   typename C1 = std::enable_if<detail::has_from_resource<T,void(T*,const basic_resource&)>::value>,
                   typename C2 = std::enable_if<std::is_default_constructible<T>::value>,
                   typename C3 = std::enable_if<std::is_move_constructible<T>::value>>
       T from_resource(const basic_resource& resource)
       {
           T value;
           T::from_resource(&value,resource);
           return std::move(value);
       }
           template <  typename T,
                   typename C1 = std::enable_if<detail::has_from_resource<T,void(T*,const basic_resource&)>::value>,
                   typename C2 = std::enable_if<std::is_move_constructible<T>::value>,
                   class ... Args>
       T from_resource(const basic_resource& resource,Args&&... args)
       {
           T value(std::forward<Args>(args)...);
           T::from_resource(&value,resource);
           return std::move(value);
       }
   
   
       template <class T,class... Args>
       A_NODISCARD T basic_resource::to(Args&&...args)
       {
           return std::move(from_resource(*this,std::forward<Args>(args)...));
       }
   
       template <class T>
       void basic_resource::from(const T& v)
       {
           to_resource(this,v);
   
       }
       #endif
   }
