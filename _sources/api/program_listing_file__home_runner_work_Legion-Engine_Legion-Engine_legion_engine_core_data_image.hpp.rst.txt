
.. _program_listing_file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_data_image.hpp:

Program Listing for File image.hpp
==================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_data_image.hpp>` (``/home/runner/work/Legion-Engine/Legion-Engine/legion/engine/core/data/image.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <core/types/primitives.hpp>
   #include <core/containers/sparse_map.hpp>
   #include <core/math/color.hpp>
   #include <core/async/readonly_rw_spinlock.hpp>
   #include <core/filesystem/view.hpp>
   #include <mutex>
   
   namespace legion::core
   {
       enum struct channel_format : uint
       {
           eight_bit = 1,
           sixteen_bit = 2,
           float_hdr = 4
       };
   
       enum struct image_components : int
       {
           grey = 1,
           grey_alpha = 2,
           rgb = 3,
           rgba = 4
       };
   
       struct image final
       {
           friend struct stb_image_loader;
           friend class ImageCache;
   
           math::ivec2 size;
           channel_format format;
           image_components components;
   
           template<typename T>
           T* get_raw_data();
   
           void apply_raw(bool lazyApply = true);
   
           const std::vector<math::color>& read_colors();
   
           size_type data_size();
   
           bool operator==(const image& other)
           {
               return m_id == other.m_id;
           }
   
           image() = default;
   
           image(const image& other) : size(other.size), format(other.format), components(other.components), m_id(other.m_id), m_dataSize(other.m_dataSize), m_pixels(other.m_pixels)
           {
               if (m_id)
               {
                   std::lock_guard guard(m_refsLock);
                   m_refs[m_id]++;
               }
           }
   
           image(image&& other) : size(other.size), format(other.format), components(other.components), m_id(other.m_id), m_dataSize(other.m_dataSize), m_pixels(other.m_pixels)
           {
               if (m_id)
               {
                   std::lock_guard guard(m_refsLock);
                   m_refs[m_id]++;
               }
           }
   
           image& operator=(const image& other)
           {
   
               {
                   std::lock_guard guard(m_refsLock);
   
                   if (m_id)
                   {
                       m_refs[m_id]--;
                       if (m_refs[m_id] == 0)
                       {
                           delete[] m_pixels;
                           m_pixels = nullptr;
                           m_refs.erase(m_id);
                       }
                   }
   
                   m_id = other.m_id;
   
                   m_refs[m_id]++;
               }
   
               size = other.size;
               format = other.format;
               components = other.components;
               m_dataSize = other.m_dataSize;
               m_pixels = other.m_pixels;
               return *this;
           }
   
           image& operator=(image&& other)
           {
               {
                   std::lock_guard guard(m_refsLock);
   
                   if (m_id)
                   {
                       m_refs[m_id]--;
                       if (m_refs[m_id] == 0)
                       {
                           delete[] m_pixels;
                           m_pixels = nullptr;
                           m_refs.erase(m_id);
                       }
                   }
   
                   m_id = other.m_id;
   
                   m_refs[m_id]++;
               }
   
               size = other.size;
               format = other.format;
               components = other.components;
               m_dataSize = other.m_dataSize;
               m_pixels = other.m_pixels;
               return *this;
           }
   
           ~image()
           {
               if (m_id)
               {
                   std::lock_guard guard(m_refsLock);
   
                   m_refs[m_id]--;
                   if (m_refs[m_id] == 0)
                   {
                       delete[] m_pixels;
                       m_pixels = nullptr;
                       m_refs.erase(m_id);
                   }
               }
           }
   
       private:
   
           static std::unordered_map<id_type, uint> m_refs;
           static std::mutex m_refsLock;
   
           id_type m_id;
           size_type m_dataSize;
           byte* m_pixels;
       };
   
       template<typename T>
       T* image::get_raw_data()
       {
           return nullptr;
       }
   
       template<>
       inline void* image::get_raw_data<void>()
       {
           return reinterpret_cast<void*>(m_pixels);
       }
   
       template<>
       inline byte* image::get_raw_data<byte>()
       {
           if (format == channel_format::eight_bit)
               return m_pixels;
           return nullptr;
       }
   
       template<>
       inline uint16* image::get_raw_data<uint16>()
       {
           if (format == channel_format::sixteen_bit)
               return reinterpret_cast<uint16*>(m_pixels);
           return nullptr;
       }
   
       template<>
       inline float* image::get_raw_data<float>()
       {
           if (format == channel_format::float_hdr)
               return reinterpret_cast<float*>(m_pixels);
           return nullptr;
       }
   
       struct image_handle
       {
           id_type id;
   
           math::ivec2 size();
   
           const std::vector<math::color>& read_colors();
   
           std::pair<async::readonly_rw_spinlock&, image&> get_raw_image();
   
           void destroy();
   
           bool operator==(const image_handle& other) { return id == other.id; }
           operator id_type() { return id; }
       };
   
       constexpr image_handle invalid_image_handle{ invalid_id };
   
       struct image_import_settings
       {
           channel_format fileFormat;
           image_components components;
           bool flipVertical;
       };
   
       constexpr image_import_settings default_image_settings{ channel_format::eight_bit, image_components::rgba, true };
   
       class ImageCache
       {
           friend class renderer;
           friend struct image;
           friend struct image_handle;
       private:
           static const std::vector<math::color> m_nullColors;
           static async::readonly_rw_spinlock m_nullLock;
   
           static std::unordered_map<id_type, std::unique_ptr<std::pair<async::readonly_rw_spinlock, image>>> m_images;
           static async::readonly_rw_spinlock m_imagesLock;
           static std::unordered_map<id_type, std::unique_ptr<std::vector<math::color>>> m_colors;
           static async::readonly_rw_spinlock m_colorsLock;
   
           static const std::vector<math::color>& process_raw(id_type id);
   
           static const std::vector<math::color>& read_colors(id_type id);
           static std::pair<async::readonly_rw_spinlock&, image&> get_raw_image(id_type id);
   
       public:
           static image_handle create_image(const std::string& name, const filesystem::view& file, image_import_settings settings = default_image_settings);
   
           static image_handle get_handle(const std::string& name);
   
           static image_handle get_handle(id_type id);
   
           static void destroy_image(const std::string& name);
   
           static void destroy_image(id_type id);
       };
   }
