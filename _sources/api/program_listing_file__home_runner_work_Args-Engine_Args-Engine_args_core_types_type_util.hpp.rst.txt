
.. _program_listing_file__home_runner_work_Args-Engine_Args-Engine_args_core_types_type_util.hpp:

Program Listing for File type_util.hpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Args-Engine_Args-Engine_args_core_types_type_util.hpp>` (``/home/runner/work/Args-Engine/Args-Engine/args/core/types/type_util.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <typeinfo>
   #include <core/types/primitives.hpp>
   #include <core/platform/platform.hpp>
   
   namespace args::core
   {
       template<typename T, typename U>
       T force_value_cast(U value)
       {
           static_assert(alignof(T) == alignof(U), "Illegal cast of unaligned types.");
           static_assert(sizeof(T) == sizeof(U), "Illegal cast of non size similar types.");
   
           return *reinterpret_cast<T*>(&value);
       }
   
       template<typename T>
       constexpr cstring typeName()
       {
           return typeid(T).name();
       }
   
       template<typename T>
       constexpr cstring typeName(T expr)
       {
           return typeid(T).name();
       }
   
       template<size_type N>
       constexpr id_type nameHash(const char(&name)[N])
       {
           id_type hash = 0xcbf29ce484222325;
           uint64 prime = 0x00000100000001b3;
           for (int i = 0; i < N - 1; i++)
           {
               byte value = name[i];
               hash = hash ^ value;
               hash *= prime;
           }
   
           return hash;
       }
   
       id_type ARGS_FUNC nameHash(cstring name);
   
       id_type ARGS_FUNC nameHash(std::string name);
   
       template<typename T>
       constexpr id_type typeHash()
       {
           id_type hash = 0xcbf29ce484222325;
           uint64 prime = 0x00000100000001b3;
           cstring name = typeid(T).name();
           while (*name != '\0')
           {
               hash = hash ^ (byte)*name;
               hash *= prime;
               name++;
           }
   
           return hash;
       }
   
       template<typename T>
       constexpr id_type typeHash(T expr)
       {
           return typeHash<T>();
       }
   }
