
.. _program_listing_file__home_runner_work_Args-Engine_Args-Engine_args_core_types_type_util.hpp:

Program Listing for File type_util.hpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Args-Engine_Args-Engine_args_core_types_type_util.hpp>` (``/home/runner/work/Args-Engine/Args-Engine/args/core/types/type_util.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <typeinfo>
   #include <core/types/primitives.hpp>
   #include <core/platform/platform.hpp>
   #include <string>
   #include <cstring>
   
   namespace args::core
   {
       template<typename T, typename U>
       T force_value_cast(U value)
       {
           static_assert(alignof(T) == alignof(U), "Illegal cast of unaligned types.");
           static_assert(sizeof(T) == sizeof(U), "Illegal cast of non size similar types.");
   
           return *reinterpret_cast<T*>(&value);
       }
   
       template<typename T>
       cstring typeName()
       {
           static cstring name = nullptr;
           if (!name)
               name = typeid(T).name();
           return name;
       }
   
       template<typename T>
       cstring undecoratedTypeName()
       {
           static char* name = nullptr;
           if (!name)
           {
               std::string typeName = typeid(T).name();
               size_type token;
               if ((token = typeName.find("struct ")) != std::string::npos)
                   typeName = typeName.substr(token + 6);
               else if ((token = typeName.find("class ")) != std::string::npos)
                   typeName = typeName.substr(token + 5);
   
               name = (char*) malloc(typeName.size());
               typeName.copy(name, std::string::npos);
               name[typeName.size()] = '\0';
           }
           return name;
       }
   
       template<typename T>
       cstring typeName(T expr)
       {
           return typeName<T>();
       }
   
       template<size_type N>
       constexpr id_type nameHash(const char(&name)[N])
       {
           id_type hash = 0xcbf29ce484222325;
           uint64 prime = 0x00000100000001b3;
           for (int i = 0; i < N - 1; i++)
           {
               byte value = name[i];
               hash = hash ^ value;
               hash *= prime;
           }
   
           return hash;
       }
   
       id_type ARGS_FUNC nameHash(cstring name);
   
       id_type ARGS_FUNC nameHash(const std::string& name);
   
       template<typename T>
       id_type typeHash()
       {
           static id_type hash = 0;
   
           if (hash == 0)
           {
               hash = 0xcbf29ce484222325;
               uint64 prime = 0x00000100000001b3;
               cstring name = undecoratedTypeName<T>();
               while (*name != '\0')
               {
                   hash = hash ^ (byte)*name;
                   hash *= prime;
                   name++;
               }
           }
   
           return hash;
       }
   
       template<typename T>
       constexpr id_type typeHash(T expr)
       {
           return typeHash<T>();
       }
   }
