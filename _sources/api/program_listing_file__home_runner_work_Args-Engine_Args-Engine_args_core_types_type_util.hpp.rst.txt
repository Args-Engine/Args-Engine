
.. _program_listing_file__home_runner_work_Args-Engine_Args-Engine_args_core_types_type_util.hpp:

Program Listing for File type_util.hpp
======================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Args-Engine_Args-Engine_args_core_types_type_util.hpp>` (``/home/runner/work/Args-Engine/Args-Engine/args/core/types/type_util.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <typeinfo>
   #include <core/types/primitives.hpp>
   #include <core/types/meta.hpp>
   #include <core/platform/platform.hpp>
   #include <string>
   #include <string_view>
   #include <cstring>
   
   namespace args::core
   {
       template<typename T, typename U>
       T force_value_cast(U value)
       {
           static_assert(alignof(T) == alignof(U), "Illegal cast of unaligned types.");
           static_assert(sizeof(T) == sizeof(U), "Illegal cast of non size similar types.");
   
           return *reinterpret_cast<T*>(&value);
       }
   
       template<typename T>
       cstring typeName()
       {
           static cstring name = nullptr;
           if (!name)
               name = typeid(T).name();
           return name;
       }
   
       template<typename T>
       cstring undecoratedTypeName()
       {
           static char* name = nullptr;
           if (!name)
           {
               std::string typeName = typeid(T).name();
               size_type token;
               if ((token = typeName.find("struct ")) != std::string::npos)
                   typeName = typeName.substr(token + 6);
               else if ((token = typeName.find("class ")) != std::string::npos)
                   typeName = typeName.substr(token + 5);
   
               name = (char*)malloc(typeName.size());
               typeName.copy(name, std::string::npos);
               name[typeName.size()] = '\0';
           }
           return name;
       }
   
       template<typename T>
       cstring typeName(T expr)
       {
           return typeName<T>();
       }
   
       template<size_type N>
       constexpr id_type nameHash(const char(&name)[N])
       {
           id_type hash = 0xcbf29ce484222325;
           uint64 prime = 0x00000100000001b3;
           for (int i = 0; i < N - 1; i++)
           {
               byte value = name[i];
               hash = hash ^ value;
               hash *= prime;
           }
   
           return hash;
       }
   
       id_type ARGS_FUNC nameHash(cstring name);
   
       id_type ARGS_FUNC nameHash(const std::string& name);
   
       id_type ARGS_FUNC nameHash(const std::string_view& name);
   
       template<typename T>
       id_type typeHash()
       {
           static id_type hash = 0;
   
           if (hash == 0)
           {
               hash = 0xcbf29ce484222325;
               uint64 prime = 0x00000100000001b3;
               cstring name = undecoratedTypeName<T>();
               while (*name != '\0')
               {
                   hash = hash ^ (byte)*name;
                   hash *= prime;
                   name++;
               }
           }
   
           return hash;
       }
   
       template<typename T>
       constexpr id_type typeHash(T expr)
       {
           return typeHash<T>();
       }
   
       template<typename Iterator>
       void appendBinaryData(Iterator first, Iterator last, byte_vec& data);
   
       template<typename T>
       void appendBinaryData(T* value, byte_vec& data)
       {
           if constexpr (has_resize<std::remove_const_t<T>, void(const std::size_t)>::value)
           {
               auto first = value->begin();
               auto last = value->end();
   
               uint64 arrSize = std::distance(first, last) * sizeof(typename decltype(first)::value_type);
   
               for (int i = 0; i < sizeof(uint64); i++)
                   data.push_back(reinterpret_cast<const byte*>(&arrSize)[i]);
   
               for (auto it = first; it != last; ++it)
                   appendBinaryData(&*it, data);
           }
           else
           {
               for (int i = 0; i < sizeof(T); i++)
                   data.push_back(reinterpret_cast<const byte*>(value)[i]);
           }
       }
   
       template<typename Iterator>
       void appendBinaryData(Iterator first, Iterator last, byte_vec& data)
       {
           uint64 arrSize = std::distance(first, last) * sizeof(typename Iterator::value_type);
           appendBinaryData(&arrSize, data);
   
           for (Iterator it = first; it != last; ++it)
               appendBinaryData(&*it, data); // dereference iterator to get reference, then get the address to get a pointer.
       }
   
       template<typename T>
       void retrieveBinaryData(T& value, byte_vec::const_iterator& start);
   
       template<typename Iterator>
       void retrieveBinaryData(Iterator first, Iterator last, byte_vec::const_iterator& start);
   
       template<typename T>
       uint64 retrieveArraySize(byte_vec::const_iterator start)
       {
           uint64 arrSize;
           retrieveBinaryData(arrSize, start);
           if (arrSize % sizeof(T) == 0)
               return arrSize / sizeof(T);
           return 0;
       }
   
       template<typename T>
       void retrieveBinaryData(T& value, byte_vec::const_iterator& start)
       {
           if constexpr (has_resize<T, void(std::size_t)>::value)
           {
               uint64 arrSize = retrieveArraySize<typename T::value_type>(start);
               value.resize(arrSize);
   
               retrieveBinaryData(value.begin(), value.end(), start);
           }
           else
           {
               memcpy(&value, &*start, sizeof(T));
   
               start += sizeof(T);
           }
       }
   
       template<typename Iterator>
       void retrieveBinaryData(Iterator first, Iterator last, byte_vec::const_iterator& start)
       {
           uint64 arrSize;
           retrieveBinaryData(arrSize, start);
   
           uint64 dist = std::distance(first, last) * sizeof(typename Iterator::value_type);
           if (dist > arrSize)
               dist = arrSize;
   
           Iterator valueIt = first;
   
           for (byte_vec::const_iterator it = start; it != (start + dist); ++valueIt)
           {
               retrieveBinaryData(*valueIt, it);
           }
   
           start += arrSize;
       }
   
   }
