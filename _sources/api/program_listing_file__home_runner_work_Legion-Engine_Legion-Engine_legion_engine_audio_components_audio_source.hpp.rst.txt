
.. _program_listing_file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_audio_components_audio_source.hpp:

Program Listing for File audio_source.hpp
=========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_audio_components_audio_source.hpp>` (``/home/runner/work/Legion-Engine/Legion-Engine/legion/engine/audio/components/audio_source.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #if !defined(DOXY_EXCLUDE)
   #include <AL/al.h>
   #include <AL/alc.h>
   #endif
   #include <audio/data/audio_segment.hpp>
   
   namespace legion::audio
   {
       struct audio_source
       {
           friend class AudioSystem;
       public:
           enum sound_properties
           {
               pitch = 1,
               gain = 2,
               playState = 4,
               doRewind = 8,
               audioHandle = 16,
               rollOffFactor = 32,
           };
   
           enum playstate
           {
               stopped,
               playing,
               paused,
           };
   
           void setPitch(const float pitch)
           {
               m_changes |= sound_properties::pitch; // set b0
               m_pitch = legion::math::max(0.0f, pitch);
           }
           float getPitch() const { return m_pitch; }
           void setGain(const float gain)
           {
               m_changes |= sound_properties::gain; // set b1
               m_gain = legion::math::max(0.0f, gain);
           }
           float getGain() const { return m_gain; };
   
           void setRollOffFactor(float factor)
           {
               m_changes = sound_properties::rollOffFactor;
               m_rolloffFactor = factor;
           }
   
           void disableSpatialAudio()
           {
               setRollOffFactor(0.0f);
           }
   
           void enableSpatialAudio()
           {
               setRollOffFactor(1.0f);
           }
   
           void play()
           {
               // If the file is already playing or if the file will be played on next update > return
               if (m_nextPlayState == playstate::playing) return;
               m_changes |= sound_properties::playState;
               m_nextPlayState = playstate::playing;
               // Do not set playstate to playing - audiosystem will set it accordingly
           }
   
           void pause()
           {
               // If the file is already playing or if the file will be played on next update > return
               if (m_nextPlayState == playstate::paused) return;
               m_changes |= sound_properties::playState;
               m_nextPlayState = playstate::paused;
               // Do not set playstate to paused - audiosystem will set it accordingly
           }
   
           void stop()
           {
               // If the file is already playing or if the file will be played on next update > return
               if (m_nextPlayState == playstate::stopped) return;
               m_changes |= sound_properties::playState;
               m_nextPlayState = playstate::stopped;
               // Do not set playstate to stopped - audiosystem will set it accordingly
           }
   
           bool isPlaying() const
           {
               return m_playState == playstate::playing;
           }
   
           bool isPaused() const
           {
               return m_playState == playstate::paused;
           }
   
           bool isStopped() const
           {
               return m_playState == playstate::stopped;
           }
   
           void setAudioHandle(audio_segment_handle handle)
           {
               if (handle == m_audio_handle) return;
               m_changes |= sound_properties::audioHandle;
               m_audio_handle = handle;
           }
   
           void rewind()
           {
               m_changes |= sound_properties::doRewind;
           }
   
           audio_segment_handle getAudioHandle() const
           {
               return m_audio_handle;
           }
   
           int getChannels()
           {
               int channels = 0;
               {
                   async::readonly_guard guard(m_audio_handle.get().first);
                   channels = m_audio_handle.get().second.channels;
               }
               return channels;
           }
   
           bool isStereo()
           {
               return getChannels() == 2;
           }
   
           bool isMono()
           {
               return getChannels() == 1;
           }
   
       private:
           void clearChanges()
           {
               m_changes ^= m_changes; // Reset
               // The next play state also needs to be reset to be able to properly switch play states
               m_nextPlayState = m_playState; 
           }
   
           ALuint m_sourceId;
           audio_segment_handle m_audio_handle = invalid_audio_segment_handle;
   
           float m_pitch = 1.0f;
           float m_gain = 1.0f;
   
           playstate m_playState = playstate::stopped;
           playstate m_nextPlayState = playstate::stopped;
   
           float m_rolloffFactor;
   
           // Byte to keep track of changes made to audio source
           // For all the values > see enum sound_properties
           // b0 - pitch
           // b1 - gain
           // b2 - play state
           // b3 - rewind (doRewind)
           // b4 - audio handle
           // b5 - roll off factor 3D
           byte m_changes = 0;
       };
   }
