
.. _program_listing_file__home_runner_work_Args-Engine_Args-Engine_args_core_ecs_component_handle.hpp:

Program Listing for File component_handle.hpp
=============================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Args-Engine_Args-Engine_args_core_ecs_component_handle.hpp>` (``/home/runner/work/Args-Engine/Args-Engine/args/core/ecs/component_handle.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <atomic>
   #include <core/common/exception.hpp>
   #include <core/ecs/ecsregistry.hpp>
   #include <core/ecs/component_container.hpp>
   #include <core/ecs/entity_handle.hpp>
   #include <core/platform/platform.hpp>
   
   namespace args::core::ecs
   {
       class component_handle_base
       {
       public:
           // Entity that owns this component.
           const entity_handle entity_handle;
   
       protected:
           EcsRegistry& m_registry;
           id_type m_ownerId;
   
       public:
           component_handle_base(id_type entityId, EcsRegistry& registry) : entity_handle(registry.getEntity(entityId)), m_registry(registry), m_ownerId(entityId) {}
   
           virtual bool valid() ARGS_IMPURE_RETURN(m_ownerId);
   
           operator bool() { return valid(); }
       };
   
       template<typename component_type>
       class component_handle : public component_handle_base
       {
       public:
           component_handle(id_type entityId, EcsRegistry& registry) : component_handle_base(entityId, registry) {}
   
           component_type read(std::memory_order order = std::memory_order_acquire)
           {
               async::transferable_atomic<component_type>* comp = m_registry.getFamily<component_type>()->get_component(m_ownerId);
               if (!comp)
                   return component_type();
   
               async::readonly_guard guard(comp->get_lock());
               if (!valid())
                   return component_type();
   
               return comp->get().load(order);
           }
   
           component_type write(component_type&& value, std::memory_order order = std::memory_order_release)
           {
               async::transferable_atomic<component_type>* comp = m_registry.getFamily<component_type>()->get_component(m_ownerId);
               if (!comp)
                   return component_type();
   
               async::readonly_guard guard(comp->get_lock());
               if (!valid())
                   return component_type();
   
               comp->get().store(value, order);
   
               return value;
           }
   
           component_type fetch_add(component_type&& value,
               std::memory_order loadOrder = std::memory_order_acquire,
               std::memory_order successOrder = std::memory_order_release,
               std::memory_order failureOrder = std::memory_order_relaxed)
           {
               async::transferable_atomic<component_type>* comp = m_registry.getFamily<component_type>()->get_component(m_ownerId);
               if (!comp)
                   return component_type();
   
               async::readonly_guard guard(comp->get_lock());
               if (!valid())
                   return component_type();
   
               component_type oldVal = comp->get().load(loadOrder);
               component_type newVal = oldVal + value;
   
               // CAS loop to assure our modification will happen correctly without overwriting some other change.
               while (!comp->get().compare_exchange_strong(oldVal, newVal, successOrder, failureOrder))
                   newVal = oldVal + value;
   
               return newVal;
           }
   
           component_type fetch_multiply(component_type&& value,
               std::memory_order loadOrder = std::memory_order_acquire,
               std::memory_order successOrder = std::memory_order_release,
               std::memory_order failureOrder = std::memory_order_relaxed)
           {
               async::transferable_atomic<component_type>* comp = m_registry.getFamily<component_type>()->get_component(m_ownerId);
               if (!comp)
                   return component_type();
   
               async::readonly_guard guard(comp->get_lock());
               if (!valid())
                   return component_type();
   
               component_type oldVal = comp->get().load(loadOrder);
               component_type newVal = oldVal * value;
   
               // CAS loop to assure our modification will happen correctly without overwriting some other change.
               while (!comp->get().compare_exchange_strong(oldVal, newVal, successOrder, failureOrder))
                   newVal = oldVal * value;
   
               return newVal;
           }
   
           void destroy()
           {
               async::transferable_atomic<component_type>* comp = m_registry.getFamily<component_type>()->get_component(m_ownerId);
               if (!comp)
                   return;
   
               async::readwrite_guard guard(comp->get_lock());
               if (valid())
                   m_registry.destroyComponent<component_type>(m_ownerId);
           }
   
           virtual bool valid() override
           {
               return m_ownerId && m_registry.getFamily<component_type>()->has_component(m_ownerId);
           }
       };
   }
