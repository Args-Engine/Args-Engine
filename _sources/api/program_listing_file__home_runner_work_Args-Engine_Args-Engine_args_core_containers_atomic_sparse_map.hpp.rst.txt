
.. _program_listing_file__home_runner_work_Args-Engine_Args-Engine_args_core_containers_atomic_sparse_map.hpp:

Program Listing for File atomic_sparse_map.hpp
==============================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Args-Engine_Args-Engine_args_core_containers_atomic_sparse_map.hpp>` (``/home/runner/work/Args-Engine/Args-Engine/args/core/containers/atomic_sparse_map.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <vector>
   #include <unordered_map>
   #include <type_traits>
   #include <algorithm>
   #include <stdexcept>
   #include <core/async/transferable_atomic.hpp>
   #include <core/async/readonly_rw_spinlock.hpp>
   #include <core/platform/platform.hpp>
   #include <core/types/primitives.hpp>
   
   namespace args::core
   {
       template <typename key_type, typename value_type, template<typename...> typename dense_type = std::vector, template<typename...> typename sparse_type = std::unordered_map>
       class atomic_sparse_map
       {
       public:
           using self_type = atomic_sparse_map<key_type, value_type, dense_type, sparse_type>;
           using self_reference = self_type&;
           using self_const_reference = const self_type&;
   
           using key_reference = key_type&;
           using key_const_reference = const key_type&;
           using key_pointer = key_type*;
   
           using atomic_type = async::transferable_atomic<value_type>;
           using atomic_reference = atomic_type&;
           using atomic_const_reference = const atomic_type&;
           using atomic_pointer = atomic_type*;
   
           using value_reference = value_type&;
           using value_const_reference = const value_type&;
           using value_pointer = value_type*;
   
           using sparse_container = sparse_type<key_type, size_type>;
           using dense_value_container = dense_type<atomic_type>;
           using dense_key_container = dense_type<key_type>;
   
           using iterator = typename dense_value_container::iterator;
           using const_iterator = typename dense_value_container::const_iterator;
   
       private:
           mutable async::readonly_rw_spinlock m_container_lock;
   
           dense_value_container m_dense_value;
           dense_key_container m_dense_key;
           sparse_container m_sparse;
   
           std::atomic<size_type> m_size = 0;
           std::atomic<size_type> m_capacity = 0;
   
       public:
           A_NODISCARD inline iterator begin()
           {
               async::readonly_guard lock(m_container_lock); return m_dense_value.begin();
           }
           A_NODISCARD inline const_iterator begin() const
           {
               async::readonly_guard lock(m_container_lock); return m_dense_value.cbegin();
           }
           A_NODISCARD inline const_iterator cbegin() const
           {
               async::readonly_guard lock(m_container_lock); return m_dense_value.cbegin();
           }
   
           A_NODISCARD inline iterator end()
           {
               async::readonly_guard lock(m_container_lock); return m_dense_value.begin() + m_size.load(std::memory_order_acquire);
           }
           A_NODISCARD inline const_iterator end() const
           {
               async::readonly_guard lock(m_container_lock); return m_dense_value.cbegin() + m_size.load(std::memory_order_acquire);
           }
           A_NODISCARD inline const_iterator cend() const
           {
               async::readonly_guard lock(m_container_lock); return m_dense_value.cbegin() + m_size.load(std::memory_order_acquire);
           }
   
           A_NODISCARD inline size_type size() const noexcept { return m_size.load(std::memory_order_acquire); }
   
           A_NODISCARD inline size_type capacity() const noexcept { return m_capacity.load(std::memory_order_acquire); }
   
           A_NODISCARD size_type max_size() const noexcept { return m_dense_value.max_size(); }
   
           A_NODISCARD inline bool empty() const noexcept { return m_size.load(std::memory_order_acquire) == 0; }
   
           inline void clear() noexcept { m_size.store(0, std::memory_order_release); }
   
           inline void reserve(size_type size)
           {
               if (size > m_capacity.load(std::memory_order_acquire))
               {
                   async::readwrite_guard lock(m_container_lock);
                   m_dense_value.resize(size);
                   m_dense_key.resize(size);
                   m_capacity.store(size, std::memory_order_release);
               }
           }
   
   #pragma region count
   
           A_NODISCARD inline size_type count(key_const_reference key) const
           {
               return contains(key);
           }
   
           A_NODISCARD inline size_type count(key_type&& key) const
           {
               return contains(key);
           }
   #pragma endregion
   
   #pragma region contains
   
           A_NODISCARD inline bool contains(key_const_reference key)
           {
               async::readonly_guard lock(m_container_lock);
               return m_sparse[key] >= 0 && m_sparse[key] < m_size && m_dense_key[m_sparse[key]] == key;
           }
   
           A_NODISCARD inline bool contains(key_type&& key)
           {
               async::readonly_guard lock(m_container_lock);
               return m_sparse[key] >= 0 && m_sparse[key] < m_size && m_dense_key[m_sparse[key]] == key;
           }
   
           A_NODISCARD inline bool contains(key_const_reference key) const
           {
               async::readonly_guard lock(m_container_lock);
               return m_sparse.count(key) && m_sparse.at(key) >= 0 && m_sparse.at(key) < m_size && m_dense_key[m_sparse.at(key)] == key;
           }
   
           A_NODISCARD inline bool contains(key_type&& key) const
           {
               async::readonly_guard lock(m_container_lock);
               return m_sparse.count(key) && m_sparse.at(key) >= 0 && m_sparse.at(key) < m_size && m_dense_key[m_sparse.at(key)] == key;
           }
   #pragma endregion
   
   #pragma region find
   
           A_NODISCARD inline iterator find(atomic_const_reference val)
           {
               async::readonly_guard lock(m_container_lock);
               return std::find(begin(), end(), val);
           }
   
           A_NODISCARD inline const_iterator find(atomic_const_reference val) const
           {
               async::readonly_guard lock(m_container_lock);
               return std::find(begin(), end(), val);
           }
   #pragma endregion
   
   #pragma region insert
   
           inline std::pair<iterator, bool> insert(key_const_reference key, value_const_reference val)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   itr_value->store(val, std::memory_order_release);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size;
                   ++m_size;
                   return std::make_pair(itr_value, true);
               }
               return std::make_pair(end(), false);
           }
   
           inline std::pair<iterator, bool> insert(key_type&& key, value_const_reference val)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   itr_value->store(val, std::memory_order_release);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = std::move(key);
   
                   m_sparse[*itr_key] = m_size;
                   ++m_size;
                   return std::make_pair(itr_value, true);
               }
               return std::make_pair(end(), false);
           }
   
           inline std::pair<iterator, bool> insert(key_const_reference key, value_type&& val)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   itr_value->store(std::move(val), std::memory_order_release);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size;
                   ++m_size;
                   return std::make_pair(itr_value, true);
               }
               return std::make_pair(end(), false);
           }
   
           inline std::pair<iterator, bool> insert(key_type&& key, value_type&& val)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   itr_value->store(val, std::memory_order_release);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size;
                   ++m_size;
                   return std::make_pair(itr_value, true);
               }
               return std::make_pair(end(), false);
           }
   #pragma endregion
   
   #pragma region emplace
   
           template<typename... Arguments>
           inline std::pair<iterator, bool> emplace(key_const_reference key, Arguments&&... arguments)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   itr_value->get().store(std::forward<value_type>(value_type(arguments...)), std::memory_order_release);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size;
                   ++m_size;
   
                   return std::make_pair(itr_value, true);
               }
   
               return std::make_pair(end(), false);
           }
   
           template<typename... Arguments>
           inline std::pair<iterator, bool> emplace(key_type&& key, Arguments&&... arguments)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   itr_value->get().store(std::forward<value_type>(value_type(arguments...)), std::memory_order_release);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size;
                   ++m_size;
   
                   return std::make_pair(itr_value, true);
               }
   
               return std::make_pair(end(), false);
           }
   #pragma endregion
   
   #pragma region operator[]
   
           inline atomic_reference operator[](key_type&& key)
           {
               key_type k;
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   itr_value->get().store(std::forward<value_type>(value_type()), std::memory_order_release);
   
                   auto itr_key = m_dense_key.begin() + m_size; // Find iterator location at which to store the key.
                   *itr_key = std::move(key); // Move the key into the location.
                   k = *itr_key; // Fetch a copy of the key for reuse in the rest of the function.
                   m_sparse[k] = m_size;
                   ++m_size;
               }
               else
                   k = key;
   
               async::readonly_guard readonlyLock(m_container_lock);
   
               return m_dense_value[m_sparse[k]];
           }
   
           inline atomic_reference operator[](key_const_reference key)
           {
               if (!contains(key))
               {
                   if (m_size >= m_capacity)
                       reserve(m_size + 1);
   
                   async::readwrite_guard lock(m_container_lock);
   
                   auto itr_value = m_dense_value.begin() + m_size;
                   itr_value->get().store(std::forward<value_type>(value_type()), std::memory_order_release);
   
                   auto itr_key = m_dense_key.begin() + m_size;
                   *itr_key = key;
   
                   m_sparse[key] = m_size;
                   ++m_size;
               }
   
               async::readonly_guard readonlyLock(m_container_lock);
   
               return m_dense_value[m_sparse[key]];
           }
   
           inline atomic_const_reference operator[](key_type&& key) const
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key and is non modifiable.");
   
               async::readonly_guard lock(m_container_lock);
   
               return m_dense_value[m_sparse.at(key)];
           }
   
           inline atomic_const_reference operator[](key_const_reference key) const
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key and is non modifiable.");
   
               async::readonly_guard lock(m_container_lock);
   
               return m_dense_value[m_sparse.at(key)];
           }
   #pragma endregion
   
   #pragma region get
   
           inline atomic_reference get(key_type&& key)
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key.");
   
               async::readonly_guard lock(m_container_lock);
   
               return m_dense_value[m_sparse[key]];
           }
   
           inline atomic_reference get(key_const_reference key)
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key.");
   
               async::readonly_guard lock(m_container_lock);
   
               return m_dense_value[m_sparse[key]];
           }
   
           inline atomic_const_reference get(key_type&& key) const
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key and is non modifiable.");
   
               async::readonly_guard lock(m_container_lock);
   
               return m_dense_value[m_sparse.at(key)];
           }
   
           inline atomic_const_reference get(key_const_reference key) const
           {
               if (!contains(key))
                   throw std::out_of_range("Sparse map does not contain this key and is non modifiable.");
   
               async::readonly_guard lock(m_container_lock);
   
               return m_dense_value[m_sparse.at(key)];
           }
   #pragma endregion
   
           inline size_type erase(key_const_reference key)
           {
               if (contains(key))
               {
                   async::readwrite_guard lock(m_container_lock);
   
                   m_dense_value[m_sparse[key]] = m_dense_value[m_size - 1];
                   m_dense_key[m_sparse[key]] = m_dense_key[m_size - 1];
                   m_sparse[m_dense_key[m_size - 1]] = m_sparse[key];
                   --m_size;
                   return true;
               }
               return false;
           }
       };
   }
