
.. _program_listing_file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_ecs_ecsregistry.hpp:

Program Listing for File ecsregistry.hpp
========================================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_ecs_ecsregistry.hpp>` (``/home/runner/work/Legion-Engine/Legion-Engine/legion/engine/core/ecs/ecsregistry.hpp``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #pragma once
   #include <core/containers/containers.hpp>
   #include <core/types/types.hpp>
   #include <core/common/common.hpp>
   #include <core/async/async.hpp>
   #include <core/ecs/component_container.hpp>
   #include <core/ecs/queryregistry.hpp>
   #include <core/ecs/entityquery.hpp>
   #include <core/ecs/entity_handle.hpp>
   #include <core/ecs/archetype.hpp>
   
   #include <utility>
   #include <memory>
   
   namespace legion::core::ecs
   {
   #define world_entity_id 1
   
       class component_handle_base;
   
       template<typename component_type>
       class component_handle;
   
       struct entity_data
       {
           id_type parent;
           entity_set children;
           hashed_sparse_set<id_type> components;
       };
   
       class EcsRegistry
       {
       private:
           static id_type m_nextEntityId;
   
           mutable async::readonly_rw_spinlock m_familyLock;
           sparse_map<id_type, std::unique_ptr<component_container_base>> m_families;
   
           mutable async::readonly_rw_spinlock m_entityDataLock;
           sparse_map<id_type, entity_data> m_entityData;
   
           mutable async::readonly_rw_spinlock m_entityLock;
           sparse_set<id_type> m_containedEntities;
           entity_set m_entities;
   
           QueryRegistry m_queryRegistry;
           events::EventBus* m_eventBus;
   
           void recursiveDestroyEntityInternal(id_type entityId);
   
       public:
           entity_handle world;
   
           EcsRegistry(events::EventBus* eventBus);
   
           template<typename component_type>
           void reportComponentType()
           {
               async::readwrite_guard guard(m_familyLock);
               if (!m_families.contains(typeHash<component_type>()))
                   m_families[typeHash<component_type>()] = std::make_unique<component_container<component_type>>(this, m_eventBus);
           }
   
           template<typename component_type>
           L_NODISCARD component_container<component_type>* getFamily()
           {
               return static_cast<component_container<component_type>*>(getFamily(typeHash<component_type>()));
           }
   
           L_NODISCARD component_container_base* getFamily(id_type componentTypeId);
   
           L_NODISCARD bool hasComponent(id_type entityId, id_type componentTypeId);
   
           template<typename component_type, typename = doesnt_inherit_from<component_type, archetype_base>>
           L_NODISCARD bool hasComponent(id_type entityId)
           {
               return hasComponent(entityId, typeHash<component_type>());
           }
   
           template<typename component_type, typename... component_types, typename = doesnt_inherit_from<component_type, archetype_base>>
           L_NODISCARD bool hasComponents(id_type entityId)
           {
               return hasComponent<component_type>(entityId) && (hasComponent<component_types>(entityId) && ...);
           }
   
           template<typename archetype_type, typename = inherits_from<archetype_type, archetype_base>>
           L_NODISCARD bool hasComponents(id_type entityId)
           {
               return archetype_type::has(this, entityId);
           }
   
           L_NODISCARD component_handle_base getComponent(id_type entityId, id_type componentTypeId);
   
           template<typename component_type, typename = doesnt_inherit_from<component_type, archetype_base>>
           L_NODISCARD component_handle<component_type> getComponent(id_type entityId)
           {
               return getComponent(entityId, typeHash<component_type>()).template cast<component_type>();
           }
   
           template<typename component_type, typename... component_types, typename = doesnt_inherit_from<component_type, archetype_base>>
           L_NODISCARD std::tuple<component_handle<component_type>, component_handle<component_types>...> getComponents(id_type entityId)
           {
               return std::make_tuple(getComponent<component_type>(entityId), getComponent<component_types>(entityId)...);
           }
   
           template<typename archetype_type, typename = inherits_from<archetype_type, archetype_base>>
           L_NODISCARD auto getComponents(id_type entityId)
           {
               return archetype_type::get(this, entityId);
           }
   
           template<typename component_type, typename = doesnt_inherit_from<component_type, archetype_base>>
           component_handle<component_type> createComponent(id_type entityId)
           {
               return createComponent(entityId, typeHash<component_type>()).template cast<component_type>();
           }
   
           template<typename component_type, typename = doesnt_inherit_from<component_type, archetype_base>>
           component_handle<std::remove_reference_t<component_type>> createComponent(id_type entityId, component_type&& component)
           {
               std::remove_reference_t<component_type> temp = component;
               return createComponent(entityId, typeHash<std::remove_reference_t<component_type>>(), &temp).template cast<std::remove_reference_t<component_type>>();
           }
   
           template<typename component_type, typename = doesnt_inherit_from<component_type, archetype_base>>
           component_handle<std::remove_reference_t<component_type>> createComponent(id_type entityId, component_type& component)
           {
               std::remove_reference_t<component_type> temp = component;
               return createComponent(entityId, typeHash<std::remove_reference_t<component_type>>(), &temp).template cast<std::remove_reference_t<component_type>>();
           }
   
           template<typename archetype_type, typename = inherits_from<archetype_type, archetype_base>>
           auto createComponents(id_type entityId)
           {
               return archetype_type::create(this, entityId);
           }
           
           template<typename archetype_type, typename... component_types, typename = inherits_from<archetype_type, archetype_base>>
           auto createComponents(id_type entityId, component_types&&... defaultValues)
           {
               return archetype_type::create(this, entityId, std::move(defaultValues)...);
           }
   
           template<typename component_type, typename... component_types, typename = doesnt_inherit_from<component_type, archetype_base>>
           std::tuple<component_handle<component_type>, component_handle<component_types>...> createComponents(id_type entityId)
           {
               return std::make_tuple(createComponent<component_type>(entityId), createComponent<component_types>(entityId)...);
           }
   
           template<typename component_type, typename... component_types, typename = doesnt_inherit_from<component_type, archetype_base>>
           std::tuple<component_handle<std::remove_reference_t<component_type>>, component_handle<std::remove_reference_t<component_types>>...> createComponents(id_type entityId, component_type&& defaultValue, component_types&&... defaultValues)
           {
               return std::make_tuple(createComponent<std::remove_reference_t<component_type>>(entityId, std::forward<component_type>(defaultValue)), createComponent<std::remove_reference_t<component_types>>(entityId, std::forward<component_types>(defaultValues))...);
           }
   
           component_handle_base createComponent(id_type entityId, id_type componentTypeId);
   
           component_handle_base createComponent(id_type entityId, id_type componentTypeId, void* value);
   
           void destroyComponent(id_type entityId, id_type componentTypeId);
   
           template<typename component_type, typename = doesnt_inherit_from<component_type, archetype_base>>
           void destroyComponent(id_type entityId)
           {
               destroyComponent(entityId, typeHash<component_type>());
           }
   
           template<typename component_type, typename... component_types, typename = doesnt_inherit_from<component_type, archetype_base>>
           void destroyComponents(id_type entityId)
           {
               destroyComponent(entityId, typeHash<component_type>());
               (destroyComponent(entityId, typeHash<component_types>()), ...);
           }
   
           template<typename archetype_type, typename = inherits_from<archetype_type, archetype_base>>
           void destroyComponents(id_type entityId)
           {
               archetype_type::destroy(this, entityId);
           }
   
           L_NODISCARD bool validateEntity(id_type entityId);
   
           L_NODISCARD entity_handle createEntity();
   
           void destroyEntity(id_type entityId, bool recurse = true);
   
           L_NODISCARD entity_handle getEntity(id_type entityId);
   
           L_NODISCARD entity_data& getEntityData(id_type entityId);
   
           L_NODISCARD std::pair<entity_set&, async::readonly_rw_spinlock&>  getEntities();
   
           template<typename... component_types>
           L_NODISCARD EntityQuery createQuery()
           {
               return m_queryRegistry.createQuery<component_types...>();
           }
   
           L_NODISCARD EntityQuery createQuery(const hashed_sparse_set<id_type>& componentTypes)
           {
               return m_queryRegistry.createQuery(componentTypes);
           }
       };
   }
   
   #include <core/ecs/entity_handle.inl>
   #include <core/ecs/archetype.inl>
