
<!DOCTYPE html>

<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Program Listing for File logging.hpp &#8212; LegionEngine v 0.2 alpha documentation</title>
    <link rel="stylesheet" href="../_static/nameko.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="stylesheet" type="text/css" href="../_static/collapsible-lists/css/tree_view.css" />
    <script id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
    <script src="../_static/jquery.js"></script>
    <script src="../_static/underscore.js"></script>
    <script src="../_static/doctools.js"></script>
    <script src="../_static/language_data.js"></script>
    <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
    <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
   
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9">
  <link href='https://fonts.googleapis.com/css?family=Lato:400,700,400italic,700italic|Lora:400' rel='stylesheet' type='text/css'>
  <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.3.0/css/font-awesome.min.css">

  </head><body>
  
  

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="nav-item nav-item-0"><a href="../index.html">LegionEngine v 0.2 alpha documentation</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">Program Listing for File logging.hpp</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="program-listing-for-file-logging-hpp">
<span id="program-listing-file-home-runner-work-legion-engine-legion-engine-legion-engine-core-logging-logging-hpp"></span><h1>Program Listing for File logging.hpp<a class="headerlink" href="#program-listing-for-file-logging-hpp" title="Permalink to this headline">¶</a></h1>
<p>↰ <a class="reference internal" href="file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_logging_logging.hpp.html#file-home-runner-work-legion-engine-legion-engine-legion-engine-core-logging-logging-hpp"><span class="std std-ref">Return to documentation for file</span></a> (<code class="docutils literal notranslate"><span class="pre">/home/runner/work/Legion-Engine/Legion-Engine/legion/engine/core/logging/logging.hpp</span></code>)</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span>#pragma once

#define SPDLOG_HEADER_ONLY
#include &lt;sstream&gt;

#if !defined(DOXY_EXCLUDE)
#include &lt;spdlog/spdlog.h&gt;
#include &lt;spdlog/sinks/stdout_color_sinks.h&gt;
#include &lt;spdlog/sinks/rotating_file_sink.h&gt;
#include &lt;spdlog/pattern_formatter.h&gt;
#endif

#include &lt;core/platform/platform.hpp&gt;
#include &lt;thread&gt;
#include &lt;core/math/math.hpp&gt;
#include &lt;core/common/exception.hpp&gt;

#if !defined(DOXY_EXCLUDE)
namespace fmt
{
    template &lt;&gt;
    struct formatter&lt;std::thread::id&gt;
    {

        constexpr auto parse(format_parse_context&amp; ctx)
        {
            auto it = ctx.begin(), end = ctx.end();

            if (it != end &amp;&amp; *it != &#39;}&#39;)
                throw format_error(&quot;invalid format&quot;);
            return it++;
        }

        template &lt;typename FormatContext&gt;
        auto format(const std::thread::id&amp; p, FormatContext&amp; ctx) {
            std::ostringstream oss;
            oss &lt;&lt; p;
            return format_to(ctx.out(), &quot;{}&quot;, oss.str());
        }

    };

    template &lt;&gt;
    struct formatter&lt;legion::core::exception&gt;
    {

        constexpr auto parse(format_parse_context&amp; ctx)
        {
            auto it = ctx.begin(), end = ctx.end();

            if (it != end &amp;&amp; *it != &#39;}&#39;)
                throw format_error(&quot;invalid format&quot;);
            return it++;
        }

        template &lt;typename FormatContext&gt;
        auto format(const legion::core::exception&amp; error, FormatContext&amp; ctx)
        {
            return format_to(ctx.out(), &quot;[{}({}) T {}(...)] {}&quot;, error.file(), error.line(), error.func(), error.what());
        }
    };

    template &lt;&gt;
    struct formatter&lt;legion::core::fs_error&gt;
    {

        constexpr auto parse(format_parse_context&amp; ctx)
        {
            auto it = ctx.begin(), end = ctx.end();

            if (it != end &amp;&amp; *it != &#39;}&#39;)
                throw format_error(&quot;invalid format&quot;);
            return it++;
        }

        template &lt;typename FormatContext&gt;
        auto format(const legion::core::fs_error&amp; error, FormatContext&amp; ctx)
        {
            return format_to(ctx.out(), &quot;[{}({}) T {}(...)] {}&quot;, error.file(), error.line(), error.func(), error.what());
        }
    };

    template &lt;&gt;
    struct fmt::formatter&lt;legion::core::math::vec2&gt; {
        // Presentation format: &#39;f&#39; - fixed, &#39;e&#39; - exponential.
        char presentation = &#39;f&#39;;

        // Parses format specifications of the form [&#39;f&#39; | &#39;e&#39;].
        constexpr auto parse(format_parse_context&amp; ctx) {
            // auto parse(format_parse_context &amp;ctx) -&gt; decltype(ctx.begin()) // c++11
              // [ctx.begin(), ctx.end()) is a character range that contains a part of
              // the format string starting from the format specifications to be parsed,
              // e.g. in
              //
              //   fmt::format(&quot;{:f} - point of interest&quot;, point{1, 2});
              //
              // the range will contain &quot;f} - point of interest&quot;. The formatter should
              // parse specifiers until &#39;}&#39; or the end of the range. In this example
              // the formatter should parse the &#39;f&#39; specifier and return an iterator
              // pointing to &#39;}&#39;.

              // Parse the presentation format and store it in the formatter:
            auto it = ctx.begin(), end = ctx.end();
            if (it != end &amp;&amp; (*it == &#39;f&#39; || *it == &#39;e&#39;)) presentation = *it++;

            // Check if reached the end of the range:
            if (it != end &amp;&amp; *it != &#39;}&#39;)
                throw format_error(&quot;invalid format&quot;);

            // Return an iterator past the end of the parsed range:
            return it;
        }

        // Formats the point p using the parsed format specification (presentation)
        // stored in this formatter.
        template &lt;typename FormatContext&gt;
        auto format(const legion::core::math::vec2&amp; p, FormatContext&amp; ctx) {
            // auto format(const point &amp;p, FormatContext &amp;ctx) -&gt; decltype(ctx.out()) // c++11
              // ctx.out() is an output iterator to write to.
            return format_to(
                ctx.out(),
                presentation == &#39;f&#39; ? &quot;({:.1f}, {:.1f})&quot; : &quot;({:.1e}, {:.1e})&quot;,
                p.x, p.y);
        }
    };

    template &lt;&gt;
    struct fmt::formatter&lt;legion::core::math::ivec2&gt; {

        constexpr auto parse(format_parse_context&amp; ctx) {
            auto it = ctx.begin(), end = ctx.end();

            if (it != end &amp;&amp; *it != &#39;}&#39;)
                throw format_error(&quot;invalid format&quot;);
            return it++;
        }

        template &lt;typename FormatContext&gt;
        auto format(const legion::core::math::ivec2&amp; p, FormatContext&amp; ctx) {
            return format_to(
                ctx.out(),
                &quot;({}, {})&quot;,
                p.x, p.y);
        }
    };

    template &lt;&gt;
    struct fmt::formatter&lt;legion::core::math::vec3&gt; {
        char presentation = &#39;f&#39;;

        constexpr auto parse(format_parse_context&amp; ctx) {
            auto it = ctx.begin(), end = ctx.end();
            if (it != end &amp;&amp; (*it == &#39;f&#39; || *it == &#39;e&#39;)) presentation = *it++;

            if (it != end &amp;&amp; *it != &#39;}&#39;)
                throw format_error(&quot;invalid format&quot;);

            return it;
        }

        template &lt;typename FormatContext&gt;
        auto format(const legion::core::math::vec3&amp; p, FormatContext&amp; ctx) {
            return format_to(
                ctx.out(),
                presentation == &#39;f&#39; ? &quot;({:.1f}, {:.1f}, {:.1f})&quot; : &quot;({:.1e}, {:.1e}, {:.1e})&quot;,
                p.x, p.y, p.z);
        }
    };

    template &lt;&gt;
    struct fmt::formatter&lt;legion::core::math::vec4&gt; {
        char presentation = &#39;f&#39;;

        constexpr auto parse(format_parse_context&amp; ctx) {
            auto it = ctx.begin(), end = ctx.end();
            if (it != end &amp;&amp; (*it == &#39;f&#39; || *it == &#39;e&#39;)) presentation = *it++;

            if (it != end &amp;&amp; *it != &#39;}&#39;)
                throw format_error(&quot;invalid format&quot;);

            return it;
        }

        template &lt;typename FormatContext&gt;
        auto format(const legion::core::math::vec4&amp; p, FormatContext&amp; ctx) {
            return format_to(
                ctx.out(),
                presentation == &#39;f&#39; ? &quot;({:.1f}, {:.1f}, {:.1f}, {:.1f})&quot; : &quot;({:.1e}, {:.1e}, {:.1e}, {:.1e})&quot;,
                p.x, p.y, p.z, p.w);
        }
    };

    template &lt;&gt;
    struct fmt::formatter&lt;legion::core::math::color&gt; {
        char presentation = &#39;f&#39;;

        constexpr auto parse(format_parse_context&amp; ctx) {
            auto it = ctx.begin(), end = ctx.end();
            if (it != end &amp;&amp; (*it == &#39;f&#39; || *it == &#39;e&#39;)) presentation = *it++;

            if (it != end &amp;&amp; *it != &#39;}&#39;)
                throw format_error(&quot;invalid format&quot;);

            return it;
        }

        template &lt;typename FormatContext&gt;
        auto format(const legion::core::math::color&amp; p, FormatContext&amp; ctx) {
            return format_to(
                ctx.out(),
                presentation == &#39;f&#39; ? &quot;({:.1f}, {:.1f}, {:.1f}, {:.1f})&quot; : &quot;({:.1e}, {:.1e}, {:.1e}, {:.1e})&quot;,
                p.r, p.g, p.b, p.a);
        }
    };

    template &lt;&gt;
    struct fmt::formatter&lt;legion::core::math::quat&gt; {
        char presentation = &#39;f&#39;;

        constexpr auto parse(format_parse_context&amp; ctx) {
            auto it = ctx.begin(), end = ctx.end();
            if (it != end &amp;&amp; (*it == &#39;f&#39; || *it == &#39;e&#39;)) presentation = *it++;

            if (it != end &amp;&amp; *it != &#39;}&#39;)
                throw format_error(&quot;invalid format&quot;);

            return it;
        }

        template &lt;typename FormatContext&gt;
        auto format(const legion::core::math::quat&amp; p, FormatContext&amp; ctx) {
            return format_to(
                ctx.out(),
                presentation == &#39;f&#39; ? &quot;(({:.1f}, {:.1f}, {:.1f}),r: {:.1f})&quot; : &quot;(({:.1e}, {:.1e}, {:.1e}),r: {:.1e})&quot;,
                p.x, p.y, p.z, p.w);
        }
    };

}
#endif


namespace legion::core::log
{
    struct impl {
        static cstring log_file;
        static std::shared_ptr&lt;spdlog::logger&gt; logger;
        static std::shared_ptr&lt;spdlog::logger&gt; file_logger;
        static std::shared_ptr&lt;spdlog::logger&gt; console_logger;
        static std::unordered_map&lt;std::thread::id, std::string&gt; thread_names;
    };


    const static inline std::chrono::time_point&lt;std::chrono::high_resolution_clock&gt; genesis = std::chrono::high_resolution_clock::now();

    class genesis_formatter_flag : public spdlog::custom_flag_formatter
    {
    public:
        void format(const spdlog::details::log_msg&amp; msg, const std::tm&amp; tm_time, spdlog::memory_buf_t&amp; dest) override
        {
            //get seconds since engine start
            const auto now = std::chrono::high_resolution_clock::now();
            const auto time_since_genesis = now - genesis;
            const auto seconds = std::chrono::duration_cast&lt;std::chrono::duration&lt;float, std::ratio&lt;1, 1&gt;&gt;&gt;(time_since_genesis).count();

            //convert to &quot;--s.ms---&quot;
            const auto str = std::to_string(seconds);

            //append to data
            dest.append(str.data(), str.data() + str.size());

        }

        //generates a new formatter flag
        L_NODISCARD std::unique_ptr&lt;custom_flag_formatter&gt; clone() const override
        {
            return spdlog::details::make_unique&lt;genesis_formatter_flag&gt;();
        }
    };

    class thread_name_formatter_flag : public spdlog::custom_flag_formatter
    {
        void format(const spdlog::details::log_msg&amp; msg, const std::tm&amp; tm_time, spdlog::memory_buf_t&amp; dest) override
        {
            std::string thread_ident;

            if (const auto it = impl::thread_names.find(std::this_thread::get_id()); it != impl::thread_names.end())
            {
                thread_ident = it-&gt;second;
            }
            else
            {
                std::ostringstream oss;
                oss &lt;&lt; std::this_thread::get_id();
                thread_ident = oss.str();

                //NOTE(algo-ryth-mix): this conversion is not portable
                //thread_ident = std::to_string(legion::core::force_value_cast&lt;uint&gt;(std::this_thread::get_id()));
            }

            dest.append(thread_ident.data(), thread_ident.data() + thread_ident.size());
        }
        std::unique_ptr&lt;custom_flag_formatter&gt; clone() const override
        {
            return spdlog::details::make_unique&lt;thread_name_formatter_flag&gt;();

        }
    };


#define logger impl::logger


    inline void setup()
    {
#if defined(LEGION_KEEP_CONSOLE) || defined(LEGION_DEBUG)
        logger = impl::console_logger;
#else
        impl::file_logger = spdlog::rotating_logger_mt(impl::log_file, impl::log_file, 1&#39;048&#39;576, 5);
        logger = impl::file_logger;
#endif
        auto f = std::make_unique&lt;spdlog::pattern_formatter&gt;();

        f-&gt;add_flag&lt;thread_name_formatter_flag&gt;(&#39;f&#39;);
        f-&gt;add_flag&lt;genesis_formatter_flag&gt;(&#39;*&#39;);
        f-&gt;set_pattern(&quot;T+ %* [%^%=7l%$] [%=13!f] : %v&quot;);

        logger-&gt;set_formatter(std::move(f));
    }

    enum class severity
    {
        trace,   // lowest severity
        debug,
        info,
        warn,
        error,
        fatal // highest severity
    };

    inline spdlog::level::level_enum args2spdlog(severity s)
    {
        switch (s)
        {
        case severity::trace:return spdlog::level::trace;
        case severity::debug:return spdlog::level::debug;
        case severity::info: return spdlog::level::info;
        case severity::warn: return spdlog::level::warn;
        case severity::error:return spdlog::level::err;
        case severity::fatal:return spdlog::level::critical;
        }
    }

    template &lt;class... Args, class FormatString&gt;
    void println(severity s, const FormatString&amp; format, Args&amp;&amp;... a)
    {
        logger-&gt;log(args2spdlog(s),format,std::forward&lt;Args&gt;(a)...);
    }


    inline void filter(severity level)
    {
        logger-&gt;set_level(args2spdlog(level));
    }

    template&lt;class... Args, class FormatString&gt;
    void trace(const FormatString&amp; format, Args&amp;&amp;... a)
    {
        println(severity::trace, format, std::forward&lt;Args&gt;(a)...);
    }

    template&lt;class... Args, class FormatString&gt;
    void debug(const FormatString&amp; format, Args&amp;&amp;...a)
    {
        println(severity::debug, format, std::forward&lt;Args&gt;(a)...);
    }

    template&lt;class... Args, class FormatString&gt;
    void info(const FormatString&amp; format, Args&amp;&amp;...a)
    {
        println(severity::info, format, std::forward&lt;Args&gt;(a)...);
    }

    template&lt;class... Args, class FormatString&gt;
    void warn(const FormatString&amp; format, Args&amp;&amp;...a)
    {
        println(severity::warn, format, std::forward&lt;Args&gt;(a)...);
    }

    template&lt;class... Args, class FormatString&gt;
    void error(const FormatString&amp; format, Args&amp;&amp;...a)
    {
        println(severity::error, format, std::forward&lt;Args&gt;(a)...);
    }

    template&lt;class... Args, class FormatString&gt;
    void fatal(const FormatString&amp; format, Args&amp;&amp;...a)
    {
        println(severity::fatal, format, std::forward&lt;Args&gt;(a)...);
    }

}
#undef logger
</pre></div>
</div>
</div>


            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation index</a><ul>
  </ul></li>
</ul>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="../_sources/api/program_listing_file__home_runner_work_Legion-Engine_Legion-Engine_legion_engine_core_logging_logging.hpp.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
  
  </body>
</html>