#version 450
#state CULL OFF
#state DEPTH OFF
#state ALPHA OFF

generate(vertex, fragment)

#include <stdio.shinc>
#include <math_ext.shinc>

shader(vertex)
{
    void main(void)
    {
        gl_Position =  vec4(stdin(position), 1.0);
        PropagateStdIO();
    }
}


shader(fragment)
{
    uniform vec2 scale;
    uniform float bokehRadius;

    float Weigh (float coc, float radius) 
    {
        return clamp01((coc - radius + 2) / 2);
    }

    void main(void)
    {
        const int kernelSampleCount = 22;
        const vec2 kernel[kernelSampleCount] = {
            vec2(0, 0),
            vec2(0.53333336, 0),
            vec2(0.3325279, 0.4169768),
            vec2(-0.11867785, 0.5199616),
            vec2(-0.48051673, 0.2314047),
            vec2(-0.48051673, -0.23140468),
            vec2(-0.11867763, -0.51996166),
            vec2(0.33252785, -0.4169769),
            vec2(1, 0),
            vec2(0.90096885, 0.43388376),
            vec2(0.6234898, 0.7818315),
            vec2(0.22252098, 0.9749279),
            vec2(-0.22252095, 0.9749279),
            vec2(-0.62349, 0.7818314),
            vec2(-0.90096885, 0.43388382),
            vec2(-1, 0),
            vec2(-0.90096885, -0.43388376),
            vec2(-0.6234896, -0.7818316),
            vec2(-0.22252055, -0.974928),
            vec2(0.2225215, -0.9749278),
            vec2(0.6234897, -0.7818316),
            vec2(0.90096885, -0.43388376),
        };
        vec3 color = SceneColor(stdin(uv)/scale).rgb;
        float weight = 1;
        const vec2 texelSize = 1.0 / textureSize(lgn_sceneColor, 0);

        for(int k = 0; k < kernelSampleCount; k++)
        {
            vec2 o = kernel[k] * bokehRadius;
            float radius = length(o);
            o *= texelSize;
            vec4 s = SceneColor(stdin(uv)/scale+o);

            float sw = Weigh(abs(s.a), radius);
            color += s.rgb * sw;
            weight += sw;

        }

        color *= 1.0 / weight;


        fragment_color = vec4(color, 1.0);
    }
}

