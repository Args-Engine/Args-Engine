#version 450
#state CULL OFF
#state BLEND OFF

generate(vertex, geometry, fragment)

#include <stdio.shinc>
#include <utils.shinc>
#include <math_ext.shinc>

shader(vertex)
{
    in vec4 emission : 7;
    out vec4 geomEmission;
    void main(void)
    {
        gl_Position = vec4(position, 1.0);
        stdout(vertexcolor) =  vertexcolor;
        stdout(wnormal) = stdin(normal);
        geomEmission = emission;
    }
}

shader(geometry)
{
    geometry_input(points)
    geometry_output(triangle_strip, max_vertices = 4)

    in vec4 geomEmission[LGN_geom_vtxc];
    out vec4 fragEmission;
    uniform float size;

    void main(void)
    {
        mat4 mat;
        mat[0] = vec4(ViewMatrix[0][2], ViewMatrix[1][2], ViewMatrix[2][2], 0.0) * size;
        mat[1] = vec4(ViewMatrix[0][1], ViewMatrix[1][1], ViewMatrix[2][1], 0.0) * size;
        mat[2] = vec4(ViewMatrix[0][0], ViewMatrix[1][0], ViewMatrix[2][0], 0.0) * size;
        mat[3] = gl_in[0].gl_Position + vec4(0.0, -stdin(0, vertexcolor).a, 0.0, 0.0);

        fragEmission = geomEmission[0];
        stdout(vertexcolor) = stdin(0, vertexcolor);
        vec4 viewPos = ViewMatrix * gl_in[0].gl_Position;
        stdout(position) = viewPos.xyz;
        stdout(wvertex) = gl_in[0].gl_Position.xyz;
        stdout(wnormal) = stdin(0, wnormal);

        gl_Position = (ViewProjectionMatrix * mat) * vec4(0.0, -0.5, -0.5, 1.0);
        stdout(uv) = vec2(0.0);
        EmitVertex();
        gl_Position = (ViewProjectionMatrix * mat) * vec4(0.0, -0.5, 0.5, 1.0);
        stdout(uv) = vec2(1.0, 0.0);
        EmitVertex();
        gl_Position = (ViewProjectionMatrix * mat) * vec4(0.0, 0.5, -0.5, 1.0);
        stdout(uv) = vec2(0.0, 1.0);
        EmitVertex();
        gl_Position = (ViewProjectionMatrix * mat) * vec4(0.0, 0.5, 0.5, 1.0);
        stdout(uv) = vec2(1.0);
        EmitVertex();
        EndPrimitive();
    }
}

shader(fragment)
{
    in vec4 fragEmission;

    void main(void)
    {
        vec4 color = stdin(vertexcolor);
        if(length(stdin(uv) - vec2(0.5)) > 0.5 || color.a > 30.0)
            discard;

        fragment_color = vec4(pow(color.rgb, vec3(2.2)) * fragEmission.a, fragEmission.a);
        fragment_normal = vec4(stdin(wnormal), 1.0);
        fragment_position = vec4(stdin(wvertex), 1.0);
        vec3 emissive = mix(vec3(fragEmission.rgb), (color.rgb + fragEmission.rgb)*5.0, clamp01(color.a*0.5f));
        float maxVal = max(emissive.r, max(emissive.g, emissive.b));
        emissive = mix(emissive, vec3(maxVal), clamp(color.a/100.0, 0.0, 0.8));
        fragment_overdraw = vec4(emissive, 1.0);
    }
}
